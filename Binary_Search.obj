0000 2 408fbf00 00001010//setup stack in case it needs to be used
0002 2 4080b000 00001011//sets up the minimum address
0004 2 4081b100 00001012//sets up the maximum address
0006 1 40828000//moves R0 to R2
0007 1 01828100//adds in R1 to R2
0008 1 09820001//divides R2 by 2
0009 3 23b392b3 00001013 00008000 //Mem[8000] > Mem[R2] jump to true side
000c 2 20b30000 00001014 //jump to false side of if
000e 3 25b392b3 00001017 00008000//if number found, jump to end of execution
0011 2 238081b3 00001018//if out of bounds, jump to number not found
0013 2 20b30000 00001016

0080 1 40828200//mov R2 into R2 to display some sort of found
0081 1 ff000000

00c0 1 ff000000

0100 1 06808000//clears out R0
0101 1 01808201//sets R0 to be R2 + 1
0102 2 20b30000 00001015//jumps back to code

0104 1 40818200 //sets R1 to R2
0105 1 0c810001 //decrements R1
0106 2 20b30000 00001015

//array of integers
1000 4 00000015 00000022 00000040 00000047
1004 4 00000056 00000066 00000071 00000077
1008 2 00000087 00000095

1010 1 0000ffff//stack start point
1011 1 00001000//start of sorted number array
1012 1 00001009//end of sorted number array
1013 1 00000100//true side of the if
1014 1 00000104//false side of the if
1015 1 0000000e//goes to the end of the if
1016 1 00000006//start of while loop
1017 1 00000080//number found
1018 1 000000c0//number not found
8000 1 00000070//the number to find
0
